# libevent了解
## 介绍
libevent是一个异步事件处理软件函数库。libevent是一个提供异步事件通知的软件库。libevent提供了一组应用程序编程接口（API），libevent API提供的机制允许开发者为事件注册回调函数，例如文件描述符上的发生了特定事件或者等待特定事件超时，接收到信号的事件，常规的定时器超时事件。当事件发生时，libevent实例会执行回调函数。libevent 在设计上是用来替代很多事件驱动网络服务器自行实现的事件循环框架的。 也就是说，libevent可以用来取代网络服务器所使用的事件循环检查框架。

开发者通过 libevent 注册信号回调，可以编写“安全”的信号处理程序，因为用户提供的信号处理程序都不会在信号 处理上下文中运行。

开发者通过 libevent 注册信号回调，可以编写“安全”的信号处理程序，因为用户提供的信号处理程序都不会在信号 处理上下文中运行。

由于可以省去对网络的处理，且拥有不错的性能，有些软件使用libevent作为网络底层的函数库，如：memcached、Tor。

## 核心数据结构

### event_base
- 核心：事件循环（reactor）

- 封装了底层 IO 复用机制（epoll/kqueue/select/poll）。

- 维护一个 事件队列，不断 dispatch() 检查就绪的事件并调用回调。

- 是所有事件（event、bufferevent、evconnlistener）的“容器”，它们必须依附在某个 event_base 上。

👉 可以理解为 大脑，其他对象都要挂在它上面。

### event
- 最基础的事件对象。

- 绑定 (fd, 事件类型, 回调函数)。

- 类型包括：

    - IO 事件（EV_READ、EV_WRITE）

    - 信号事件

    - 定时器事件

- bufferevent、evconnlistener 的内部，都是用一堆 event 来实现的。

👉 可以理解为 神经末梢，直接负责响应某个 fd 的事件。

### bufferevent
- 封装了两个 event【绑定同一个fd】：

    - 一个负责 读事件（fd 可读）

    - 一个负责 写事件（fd 可写）

- 内部有两个 evbuffer：

    - 输入缓冲区（存放读到的数据）

    - 输出缓冲区（存放要写的数据）

- 提供了更高级的接口：

    - bufferevent_setcb（绑定读/写/错误回调）

    - bufferevent_read / bufferevent_write

让应用层不必自己反复处理 read() / write() 和 EAGAIN 错误。

👉 可以理解为 带缓存的 socket 包装器。
### evconnlistener

- 封装了一个 监听 socket + 一个 event。

- 专门处理 accept()：## 调用listen后fd进入监听状态，监听fd的可读事件就是监听套接字上有新的连接请求。 对应libevent定义的新连接事件

    - 当监听 fd 可读 → 说明有新连接 → 内部自动调用 accept → 触发用户回调（accept_conn_cb）。

- 常见用法：evconnlistener_new_bind()。

👉 可以理解为 新连接分发器，自动帮你接新连接，然后交给应用。
### 核心结构关系图
```lua
                +-------------------+
                |    event_base     |   (事件循环调度中心)
                +---------+---------+
                        |
        +------------------+---------------------------+
        |                  |                           |
+-------v--------+   +-----v-----+              +------v------+
| evconnlistener |   |  event    |              | bufferevent |
|                |   | (定时器等) |              |             |
| - listen_fd    |   +-----------+              | - read_event|
| - event        |                              | - write_event
| - accept_cb    |                              | - evbuffer  |
+----------------+                              +-------------+
        |
        | (accept 新连接，回调触发)
        v
应用层代码决定如何处理：
--> 一般会创建 bufferevent 来管理这个新连接

```

## 数据流图
- 以下时序图展示了基于libevent实现的代理加密传输的数据流:
客户端发消息 → 代理转发 → 服务端处理 → 服务端回消息 → 代理转发 → 客户端收到，整个过程的链路。

```lua
客户端                        代理 (proxy)                               服务端
   |                             |                                          |
   | 1. TCP连接建立              |                                          |
   |---------------------------->| (evconnlistener接收连接)                 |
   |                             | 生成 clientBufferEvent   绑定到 client_fd |
   |                             | 生成 serverBufferEvent                   |
   | 2. 发送数据                  |代理连接服务端 将serverBufferEvent绑定到server_fd |
   |---------------------------->|                                          |
   |                             | (event_base检测 client_fd 可读)           |
   |                             |--> clientReadCb                          |
   |                             |   [读取数据, 加密/封包]                   |
   |                             |   bufferevent_write(serverBufferEvent)   |
   |                             |-----------------------> server_fd        |
   |                             |                                          |
   |                             | 3. 转发数据                              |
   |                             | (serverBufferEvent写缓冲→TCP发送)         |
   |                             |----------------------------->            |
   |                             |                                          |
   |                             |                             4. 服务端处理|
   |                             |<-----------------------------            |
   |                             | (event_base检测 server_fd 可读)          |
   |                             |--> serverReadCb                          |
   |                             |   [读取数据, 解密/解包]                   |
   |                             |   bufferevent_write(clientBufferEvent)   |
   |                             |-----------------------> client_fd        |
   |                             |                                          |
   | 5. 客户端收到响应            |                                          |
   |<----------------------------|                                          |

```
**流程解读：**

1. 建立连接：客户端连到代理，代理用 evconnlistener 接收，生成 clientBufferEvent，并建立到服务端的 serverBufferEvent。

2. 客户端发数据：clientReadCb 触发 → 加密/封装 → 写入 serverBufferEvent → 发给服务端。

3. 服务端处理并返回数据：数据到达代理 → serverReadCb 触发 → 解密/解包 → 写入 clientBufferEvent → 发回客户端。

4. 客户端收到响应，完成一次双向数据传输。
