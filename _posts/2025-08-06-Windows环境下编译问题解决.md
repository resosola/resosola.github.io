# Windows环境下编译问题解决
C++代码在Windows环境下编译时，可能会遇到一些常见的问题。以下是一些解决方案和建议：
## 1. 三方库接入问题
- 对于常见三方库，可使用conan进行管理，避免手动编译和链接。
    示例conanfile.txt：
    ```
    [requires]
    yaml-cpp/0.7.0
    openssl/1.1.1k
    nlohmann_json/3.11.2
    spdlog/1.11.0
    libevent/2.1.12
    cpp-httplib/0.11.0
    [options]
    OpenSSL:shared=False
    spdlog:shared=False
    libevent:shared=False
    httplib:shared=False
    [generators]
    cmake_find_package
    ```
    CMakeLists.txt中添加：
    ```CMake
    set(third_dir ${CMAKE_SOURCE_DIR}/3dparty)
    set(conan "conan_1.59.0")
    include(${third_dir}/${conan}/conan.cmake)
    find_package(OpenSSL REQUIRED)
    find_package(nlohmann_json REQUIRED)
    find_package(Libevent REQUIRED)
    find_package(spdlog REQUIRED)
    find_package(httplib REQUIRED)
    target_link_libraries(client_proxy 
        -Wl,-Bstatic
        spdlog::spdlog 
        yaml-cppd
        libevent::libevent
        OpenSSL::SSL 
        OpenSSL::Crypto 
        httplib::httplib
    )
    ```
- 对于不常用的三方库，可手动编译并链接，注意设置好编译选项和链接选项。
    使用gmssl库作为示例，三方库结构如下：
    ```
    spu_deploy@node1:~/liu/db_proxy/3dparty/gmssl_3.1.0$ tree -L 2
    .
    ├── arm
    │   └── lib
    ├── gmssl.cmake
    ├── include
    │   └── gmssl
    ├── lib
    │   └── libgmssl.a
    └── win
        └── lib
            ├── libgmssl.a
    ```
    gmssl.cmake内容如下：
    ```CMake
    include_guard()

    set(gmssl_INCLUDE ${third_dir}/${gmssl}/include)

    set(gmssl_lib_name libgmssl.a)

    if(CMAKE_HOST_SYSTEM_PROCESSOR MATCHES "aarch64")
        message("this is aarch64 cpu")
        set(gmssl_LIBS ${third_dir}/${gmssl}/arm/lib)
    elseif(CMAKE_HOST_SYSTEM_PROCESSOR MATCHES "x86_64")
        message("this is x86_64 cpu")
        set(gmssl_LIBS ${third_dir}/${gmssl}/lib)
    endif()
    if(${CMAKE_SYSTEM_NAME} STREQUAL "Windows")
        set(gmssl_LIBS ${third_dir}/${gmssl}/win/lib)
    endif()
    ```
    CMakeLists.txt中添加：
    ```CMake
    set(third_dir ${CMAKE_SOURCE_DIR}/3dparty)
    include(${third_dir}/gmssl_3.1.0/gmssl.cmake)
    include_directories(${gmssl_INCLUDE})
    link_directories(${gmssl_LIBS})
    target_link_libraries(client_proxy
        ...
        libgmssl.a
    )
    ```

## 2、三方库编译问题
- 一般通过github地址获取源码，然后在Windows环境下编译。
- 如编译gmssl库，我是在https://github.com/guanzhi/GmSSL 获取源码，然后切到对应版本进行编译
### 注意主程序和三方库的编译工具链要保持一致
- 因为不同编译工具链的库是不能直接链接的，所以主程序和三方库的编译工具链要保持一致。
    - 如果使用mingw编译三方库，主程序也要使用mingw编译。
    - 如果使用Visual Studio编译三方库，主程序也要使用Visual Studio编译。
- 不同编译工具的库格式不同

| 编译器/工具链      | 静态库扩展名 | 动态库扩展名 | 导入库扩展名 |
| ----------- | ----------- | ----------- | ----------- |
| GCC (MinGW)      | .a       | .dll       | .dll.a       |
| MSVC   | .lib	        | .dll        | .lib       |
- 如果主程序使用mingw编译，三方库使用Visual Studio编译，会导致链接错误，提示找不到符号。
- Linux 下的 .a 文件和 Windows (MinGW) 下的 .a 文件并不通用。虽然它们都是 GNU 的 ar 工具生成的 .a 静态库文件，但目标平台不一样，所以不能在另一个平台直接使用。
    - Linux 下 GCC 默认生成 ELF 格式 的目标文件。
    - Windows 下 MinGW GCC 生成的是 PE/COFF 格式（Windows 用的可执行格式）。


### 区分.lib是导入库还是静态库
- 有时会遇到链接的其实是导入库而不是静态库，如果链接的是导入库，在执行时会需要对应的动态库，否则执行失败。
    - 看文件大小（简单快速）
        - 静态库文件通常较小，而导入库文件通常较大，一般几十KB是导入库，几MB是静态库
    - 可以使用`dumpbin /headers xxx.lib`命令查看.lib文件的类型，如果是导入库，会显示`DLL`字样。【 Visual Studio 提供】
    - nm 命令（MinGW）来查看 .lib 或 .a 文件是否包含完整的符号（从而判断它是静态库还是仅是 DLL 的导入库）
    ```bash
    nm gmssl.lib
    00000000 I __imp_SSL_new
    00000000 I __imp_SSL_CTX_new
    00000000 I __imp_SSL_connect
    看到这样的内容（少量符号 + __imp_ 前缀），说明是导入库。
    ```
- 静态库和导入库的区别
    - 静态库：包含了函数和数据的二进制代码，链接时会将静态库的代码复制到可执行文件中。
    - 导入库：只包含了函数和数据的符号引用，链接时会在运行时动态加载对应的动态库。
### 三方库的源码可能不支持编译成静态库
- 一般增加`  -DBUILD_SHARED_LIBS=OFF `选项来编译静态库。
- 有些三方库的源码可能默认只支持编译成动态库，一般需要修改源码的CMakeLists文件
    比如GmSSL 3.1.0版本，默认只支持编译成动态库，不支持编译成静态库，其CMakeLists文件含有以下内容：
    ```CMake
    add_library(gmssl ${src})
    add_library(sdf_dummy SHARED src/sdf/sdf_dummy.c)
    add_library(skf_dummy SHARED src/skf/skf_dummy.c)
    ```
    需要改成这样 再重新编译才能编译出静态库:
    ```CMake
    add_library(gmssl STATIC ${src})
    add_library(sdf_dummy STATIC src/sdf/sdf_dummy.c)
    add_library(skf_dummy STATIC src/skf/skf_dummy.c)
    ```
